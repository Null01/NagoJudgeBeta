/*
 * Codejudge
 * Copyright 2012, Sankha Narayan Guria (sankha93@gmail.com)
 * Licensed under MIT License.
 *
 * Codejudge Compiler Server: The base interface for each language
 */
package edu.nagojudge.business.codejuge.language;

import edu.nagojudge.msg.pojo.JudgeMessage;
import edu.nagojudge.msg.pojo.MetadataMessage;
import edu.nagojudge.msg.pojo.PairMessage;
import edu.nagojudge.msg.pojo.constants.TypeStateJudgeEnum;
import edu.nagojudge.tools.security.constants.TypeSHAEnum;
import edu.nagojudge.tools.utils.FileUtil;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.log4j.Logger;

public abstract class AbstractLanguage {

    private final Logger logger = Logger.getLogger(AbstractLanguage.class);

    public final String NAME_FILE_SHELL_COMPILE = "_compile.sh";
    public final String NAME_FILE_SHELL_EXECUTE = "_run.sh";
    public final String NAME_FILE_SHELL_DIFF = "_diff.sh";
    public final String NAME_FILE_ERROR_COMPILATION = "error_compile.txt";
    public final String NAME_FILE_OUTPUT_EXECUTE = "output.txt";
    public final String NAME_FILE_DIFF_OUTPUT_EXECUTE = "diff_output.txt";
    public final String DIR_WORKSPACE_EXECUTE = "workspace";
    public boolean isTimeout = false;
    public MetadataMessage metadata;

    public static final Map<String, String> i18 = new HashMap<String, String>();

    static {
        i18.put("label.tl.es", "Tu programa no es optimo, revisa tu codigo.");
        i18.put("label.ce.rename.es", "El archivo [:param1] no fue renombrado a un archivo temporal [:param2].");
        i18.put("label.ac.es", "Bien hecho, solucion correcta.");
        i18.put("label.wr.precision.es", "Existe diferencias en tus respuestas, revisa la precicion numerica.");
        i18.put("label.wr.spaces.es", "Existe diferencias en tus respuestas, revisa espacios en blanco generados.");
        i18.put("label.wr.caseletter.es", "Existe diferencias en tus respuestas, revisa letras mayusculas, minusculas y signos.");
        i18.put("label.wr.generic.es", "Revisa el formato de salida, generada por tu codigo.");

        i18.put("label.tl.en", "Your program is not optimize.");
        i18.put("label.ce.rename.en", "The file source [:param1] was not renamed to temporality file [:param2].");
        i18.put("label.ac.en", "Great. Congratulations solved is correct.");
        i18.put("label.wr.precision.en", "Exist differences in your answers, check the numerical precision.");
        i18.put("label.wr.spaces.en", "Exist differences in your answers, check the black spaces generated.");
        i18.put("label.wr.caseletter.en", "Exist differences in your answers, check the upper case, letter case and others signes.");
        i18.put("label.wr.generic.en", "Check the format of output file generated by your code.");
    }

    public AbstractLanguage(MetadataMessage metadata) {
        this.metadata = metadata;
    }

    public abstract JudgeMessage execute(); // method to override when executing a program

    public abstract JudgeMessage compile(); // method to override when compiling a program

    public JudgeMessage analyze(final String pathFileCodeSource, final String fullPathFileOutputServer, final String checksumFileOutputServer) {
        JudgeMessage judgeMessage = new JudgeMessage();
        judgeMessage.setKeyStatus(null);
        try {
            logger.debug("START PROCESS JUDGE - analyze()");
            final String pathFileWorkspaceExecute = pathFileCodeSource + File.separatorChar + DIR_WORKSPACE_EXECUTE;
            File file = new File(pathFileWorkspaceExecute, NAME_FILE_OUTPUT_EXECUTE);
            if (file.exists()) {
                try {
                    String checksumFileOutputUser = FileUtil.getInstance().generateCheckSum(pathFileWorkspaceExecute, NAME_FILE_OUTPUT_EXECUTE, TypeSHAEnum.SHA256);
                    logger.debug("checksumFileOutputServer [" + checksumFileOutputServer + "] - checksumFileOutputUser [" + checksumFileOutputUser + "]");
                    boolean judge = checksumFileOutputServer.compareTo(checksumFileOutputUser) == 0;
                    judgeMessage.setKeyStatus((judge) ? TypeStateJudgeEnum.AC.name() : TypeStateJudgeEnum.WR.name());
                    logger.debug("analyze complete @ECHO");
                    if (!judge) {
                        String msgJudge = generateMessageJudgeOfDiffResults(pathFileWorkspaceExecute, fullPathFileOutputServer, pathFileWorkspaceExecute + File.separatorChar + NAME_FILE_OUTPUT_EXECUTE);
                        judgeMessage.setMessageJudge(msgJudge);
                        logger.debug("analyze wrong answer complete @ECHO");
                    } else {
                        judgeMessage.setMessageJudge(i18.get("label.ac." + metadata.getI18()));
                    }
                } catch (IOException ex) {
                    logger.error(ex);
                    judgeMessage.setKeyStatus(TypeStateJudgeEnum.RE.name());
                    judgeMessage.setMessageJudge(ex.getMessage());
                } catch (NoSuchAlgorithmException ex) {
                    logger.error(ex);
                    judgeMessage.setKeyStatus(TypeStateJudgeEnum.RE.name());
                    judgeMessage.setMessageJudge(ex.getMessage());
                } finally {

                }
            }
        } finally {
            logger.debug("ENDING PROCESS JUDGE - analyze()");
        }
        return judgeMessage;
    }

    private String generateMessageJudgeAnalyzeResultset(List<PairMessage> diffResults) {
        String messageJudge = i18.get("label.wr.generic." + metadata.getI18());
        if (diffResults != null) {
            for (PairMessage pair : diffResults) {
                logger.debug(pair);
            }
        }
        return messageJudge;
    }

    // method to return the compiler errors
    public StringBuilder getCompileErrors(final String pathFile) {
        String line;
        StringBuilder content = new StringBuilder();
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new InputStreamReader(new FileInputStream(new File(pathFile, NAME_FILE_ERROR_COMPILATION))));
            while ((line = reader.readLine()) != null) {
                content.append(line.trim()).append("\n");
            }
            if (content.length() < 1) {
                content = null;
            }
        } catch (FileNotFoundException e) {
            logger.error(e);
        } catch (IOException e) {
            logger.error(e);
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException ex) {
                    logger.error(ex);
                }
            }
        }
        return content;
    }

    // method to return the lists of differences beetwen two files
    public String generateMessageJudgeOfDiffResults(final String pathFileCodeSource, final String fullPathFileOutputServer, final String fullPathFileOutputUser) {
        String line, first = null, messageJudge = null;
        BufferedReader reader = null;
        BufferedWriter out = null;
        final int MAX_NUMBER_OF_CASE_OF_DIFF = 3;
        int it = 0;
        List<PairMessage> diffResults = new ArrayList<PairMessage>();
        try {
            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(pathFileCodeSource, NAME_FILE_SHELL_DIFF))));
            out.write("cd \"" + pathFileCodeSource + "\"\n");
            out.write("diff " + fullPathFileOutputUser + " " + fullPathFileOutputServer + " > " + NAME_FILE_DIFF_OUTPUT_EXECUTE);
            out.close();
            Runtime r = Runtime.getRuntime();
            Process p = r.exec("chmod +x " + pathFileCodeSource + File.separatorChar + NAME_FILE_SHELL_DIFF);
            p.waitFor();
            p = r.exec(pathFileCodeSource + File.separatorChar + NAME_FILE_SHELL_DIFF); // execute the compiler script
            p.waitFor();
            reader = new BufferedReader(new InputStreamReader(new FileInputStream(new File(pathFileCodeSource, NAME_FILE_DIFF_OUTPUT_EXECUTE))));
            while ((line = reader.readLine()) != null) {
                if (line.startsWith("<")) {
                    first = line;
                } else {
                    if (line.startsWith(">")) {
                        diffResults.add(new PairMessage(first, line));
                        ++it;
                    }
                }
                if (it == MAX_NUMBER_OF_CASE_OF_DIFF) {
                    break;
                }
            }
            String msgJudge = generateMessageJudgeAnalyzeResultset(diffResults);
            messageJudge = (msgJudge != null) ? msgJudge : i18.get("label.wr.generic." + metadata.getI18());
        } catch (IOException ex) {
            logger.error(ex);
        } catch (InterruptedException ex) {
            logger.error(ex);
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException ex) {
                    logger.error(ex);
                }
            }
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException ex) {
                    logger.error(ex);
                }
            }
        }
        return messageJudge;
    }
}
