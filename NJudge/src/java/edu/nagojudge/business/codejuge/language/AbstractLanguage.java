package edu.nagojudge.business.codejuge.language;

import edu.nagojudge.msg.pojo.JudgeMessage;
import edu.nagojudge.msg.pojo.MetadataMessage;
import edu.nagojudge.msg.pojo.PairMessage;
import edu.nagojudge.msg.pojo.constants.TypeStateJudgeEnum;
import edu.nagojudge.tools.security.constants.TypeSHAEnum;
import edu.nagojudge.tools.utils.FileUtil;
import edu.nagojudge.tools.utils.FormatUtil;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.security.NoSuchAlgorithmException;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Map;
import java.util.Queue;
import java.util.Stack;
import org.apache.log4j.Logger;

public abstract class AbstractLanguage {

    private final Logger logger = Logger.getLogger(AbstractLanguage.class);

    public final String NAME_FILE_SHELL_COMPILE = "_compile.sh";
    public final String NAME_FILE_SHELL_EXECUTE = "_run.sh";
    public final String NAME_FILE_SHELL_DIFF = "_diff.sh";
    public final String NAME_FILE_ERROR_COMPILATION = "error_compile.txt";
    public final String NAME_FILE_OUTPUT_EXECUTE = "output.txt";
    public final String NAME_FILE_DIFF_OUTPUT_EXECUTE = "diff_output.txt";
    public final String DIR_WORKSPACE_EXECUTE = "workspace";
    public boolean isTimeout = false;
    public MetadataMessage metadata;

    public static final Map<String, String> i18 = new HashMap<String, String>();

    static {
        i18.put("label.tl.es", "Tu programa no es optimo, revisa tu codigo.");
        i18.put("label.ce.rename.es", "El archivo [:param1] no fue renombrado a un archivo temporal [:param2].");
        i18.put("label.ce.generic.es", "Recuerda tener presente las siguientes consideraciones [link], a continuacion el datalle:");
        i18.put("label.ac.es", "Bien hecho, solucion correcta.");
        i18.put("label.wr.spaces.es", "Revisa espacios en blanco generados por tu codigo, al inicio o al final de un palabra, numero, signo, etc.");
        i18.put("label.wr.caseletter.es", "Revisa letras mayusculas, minusculas y signos.");
        i18.put("label.wr.newline.es", "Revisa saltos de linea generados por tu codigo, recuerda revisar las especificaciones dadas en el enunciado del problema.");
        i18.put("label.wr.precision.es", "Revisa la precision numerica utilizada, recuerda que el tipo de dato y la cantidad de divisiones afectan la precision.");
        i18.put("label.wr.generic.es", "Revisa el formato de salida, generado por tu codigo.");

        i18.put("label.tl.en", "Your program is not optimize.");
        i18.put("label.ce.rename.en", "The file source [:param1] was not renamed to temporality file [:param2].");
        i18.put("label.ac.en", "Great. Congratulations solved is correct.");
        i18.put("label.wr.precision.en", "Exist differences in your answers, check the numerical precision.");
        i18.put("label.wr.spaces.en", "Exist differences in your answers, check the black spaces generated.");
        i18.put("label.wr.caseletter.en", "Exist differences in your answers, check the upper case, letter case and others signes.");
        i18.put("label.wr.generic.en", "Check the format of output file generated by your code.");
    }

    public AbstractLanguage(MetadataMessage metadata) {
        this.metadata = metadata;
    }

    public abstract JudgeMessage execute(); // method to override when executing a program

    public abstract JudgeMessage compile(); // method to override when compiling a program

    public JudgeMessage analyze(final String pathFileCodeSource, final String fullPathFileOutputServer, final String checksumFileOutputServer) {
        JudgeMessage judgeMessage = new JudgeMessage();
        judgeMessage.setKeyStatus(null);
        try {
            logger.debug("START PROCESS JUDGE - analyze()");
            final String pathFileWorkspaceExecute = pathFileCodeSource + File.separatorChar + DIR_WORKSPACE_EXECUTE;
            File file = new File(pathFileWorkspaceExecute, NAME_FILE_OUTPUT_EXECUTE);
            if (file.exists()) {
                try {
                    String checksumFileOutputUser = FileUtil.getInstance().generateCheckSum(pathFileWorkspaceExecute, NAME_FILE_OUTPUT_EXECUTE, TypeSHAEnum.SHA256);
                    logger.debug("checksumFileOutputServer [" + checksumFileOutputServer + "] - checksumFileOutputUser [" + checksumFileOutputUser + "]");
                    boolean judge = checksumFileOutputServer.compareTo(checksumFileOutputUser) == 0;
                    judgeMessage.setKeyStatus((judge) ? TypeStateJudgeEnum.AC.name() : TypeStateJudgeEnum.WR.name());
                    logger.debug("analyze complete @ECHO");
                    if (!judge) {
                        String msgJudge = generateMessageJudgeOfDiffResults(pathFileWorkspaceExecute, fullPathFileOutputServer, pathFileWorkspaceExecute + File.separatorChar + NAME_FILE_OUTPUT_EXECUTE);
                        judgeMessage.setMessageJudge(msgJudge);
                        logger.debug("analyze wrong answer complete @ECHO");
                    } else {
                        judgeMessage.setMessageJudge(i18.get("label.ac." + metadata.getI18()));
                    }
                } catch (IOException ex) {
                    logger.error(ex);
                    judgeMessage.setKeyStatus(TypeStateJudgeEnum.RE.name());
                    judgeMessage.setMessageJudge(ex.getMessage());
                } catch (NoSuchAlgorithmException ex) {
                    logger.error(ex);
                    judgeMessage.setKeyStatus(TypeStateJudgeEnum.RE.name());
                    judgeMessage.setMessageJudge(ex.getMessage());
                } finally {

                }
            }
        } finally {
            logger.debug("ENDING PROCESS JUDGE - analyze()");
        }
        return judgeMessage;
    }

    // method to return the compiler errors
    public StringBuilder getCompileErrors(final String pathFile) {
        String line;
        StringBuilder content = new StringBuilder();
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new InputStreamReader(new FileInputStream(new File(pathFile, NAME_FILE_ERROR_COMPILATION))));
            while ((line = reader.readLine()) != null) {
                content.append(line.trim()).append("\n");
            }
            if (content.length() < 1) {
                content = null;
            }
        } catch (FileNotFoundException e) {
            logger.error(e);
        } catch (IOException e) {
            logger.error(e);
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException ex) {
                    logger.error(ex);
                }
            }
        }
        return content;
    }

    // method to return the lists of differences beetwen two files
    public String generateMessageJudgeOfDiffResults(final String pathFileCodeSource, final String fullPathFileOutputServer, final String fullPathFileOutputUser) {
        String line, messageJudge = null;
        BufferedReader reader = null;
        BufferedWriter out = null;
        final int MAX_NUMBER_OF_CASE_OF_DIFF = 3;
        int it = 0;
        Stack<PairMessage> diffResults = new Stack<PairMessage>();
        try {
            out = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(new File(pathFileCodeSource, NAME_FILE_SHELL_DIFF))));
            out.write("cd \"" + pathFileCodeSource + "\"\n");
            out.write("diff " + fullPathFileOutputUser + " " + fullPathFileOutputServer + " > " + NAME_FILE_DIFF_OUTPUT_EXECUTE);
            out.close();
            Runtime r = Runtime.getRuntime();
            Process p = r.exec("chmod +x " + pathFileCodeSource + File.separatorChar + NAME_FILE_SHELL_DIFF);
            p.waitFor();
            p = r.exec(pathFileCodeSource + File.separatorChar + NAME_FILE_SHELL_DIFF); // execute the compiler script
            p.waitFor();
            reader = new BufferedReader(new InputStreamReader(new FileInputStream(new File(pathFileCodeSource, NAME_FILE_DIFF_OUTPUT_EXECUTE))));
            while ((line = reader.readLine()) != null) {
                if (line.startsWith("<")) {
                    diffResults.push(new PairMessage(line, null));
                } else {
                    if (line.startsWith(">")) {
                        diffResults.peek().setSecond(line);
                        ++it;
                    }
                }
                if (it == MAX_NUMBER_OF_CASE_OF_DIFF) {
                    break;
                }
            }
            String msgJudge = generateMessageJudgeAnalyzeResultset(new LinkedList<PairMessage>(diffResults));
            messageJudge = (msgJudge != null) ? msgJudge : i18.get("label.wr.generic." + metadata.getI18());
        } catch (IOException ex) {
            logger.error(ex);
        } catch (InterruptedException ex) {
            logger.error(ex);
        } finally {
            if (out != null) {
                try {
                    out.close();
                } catch (IOException ex) {
                    logger.error(ex);
                }
            }
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException ex) {
                    logger.error(ex);
                }
            }
        }
        return messageJudge;
    }

    private String generateMessageJudgeAnalyzeResultset(Queue<PairMessage> diffResults) {
        if (diffResults != null) {
            for (PairMessage pair : diffResults) {
                logger.debug(pair);
            }
            PairMessage pair = diffResults.poll();
            if (pair.getFirst() != null && pair.getSecond() != null) {
                String a = FormatUtil.getInstance().nvl(pair.getFirst(), "");
                String b = FormatUtil.getInstance().nvl(pair.getSecond(), "");
                a = (a.length() > 2) ? a.substring(2) : a;
                b = (b.length() > 2) ? b.substring(2) : b;
                if (FormatUtil.getInstance().isValidNumberFloatPoint(a) && FormatUtil.getInstance().isValidNumberFloatPoint(b)) {
                    int lastIndexOf_a = a.lastIndexOf(".");
                    int lastIndexOf_b = b.lastIndexOf(".");
                    if (lastIndexOf_a > 0 && lastIndexOf_b > 0 && lastIndexOf_a == lastIndexOf_b) {
                        if (a.substring(0, lastIndexOf_a).compareTo(b.substring(0, lastIndexOf_b)) == 0) {
                            return i18.get("label.wr.precision." + metadata.getI18());
                        }
                    }
                }
                if (a.compareToIgnoreCase(b) == 0) {
                    return i18.get("label.wr.caseletter." + metadata.getI18());
                }
                if (a.trim().length() == b.trim().length() && a.compareTo(b) == 0) {
                    return i18.get("label.wr.spaces." + metadata.getI18());
                }

            }
        } else {
            return i18.get("label.wr.newline." + metadata.getI18());
        }
        return i18.get("label.wr.generic." + metadata.getI18());
    }

}
